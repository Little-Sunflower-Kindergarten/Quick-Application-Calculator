'use strict';

/*
 * Copyright (C) 2017, hapjs.org. All rights reserved.
 */

module.exports = function (babel) {
  var t = babel.types;
  return {
    inherits: require('babel-plugin-syntax-jsx'),
    visitor: {
      JSXNamespacedName: function JSXNamespacedName(path) {
        throw path.buildCodeFrameError('不支持带命名空间的标签/属性');
      },

      JSXElement: {
        exit: function exit(path, file) {
          // 将jsx标签转换为createElement函数调用
          var callExpr = buildElementCall(path.get('openingElement'), file);
          // 将孩子属性作为函数的第3个参数
          var tagExpr = convertJSXIdentifier(path.get('openingElement').node.name);
          // 取出标签名
          var tagName = void 0;
          if (t.isIdentifier(tagExpr)) {
            tagName = tagExpr.name;
          }
          var children = path.node.children.map(function (item) {
            // 将所有jsxText替换为<text>或<span>
            if (t.isStringLiteral(item)) {
              return buildTextElementCall(tagName === 'text' ? 'span' : 'text', item.value, file);
            }
            return item;
          });
          callExpr.arguments.push(t.arrayExpression(children));
          // 将jsx代码替换为$createElement函数调用
          path.replaceWith(t.inherits(callExpr, path.node));
        }
      },
      'Program': function Program(path) {
        // 只检查函数中的jsx代码
        path.traverse({
          'ObjectMethod|FunctionExpression|ClassMethod': function ObjectMethodFunctionExpressionClassMethod(path) {
            // 检查函数中是否包含jsx代码
            var jsxChecker = {
              hasJsx: false
            };
            path.traverse({
              JSXElement: function JSXElement() {
                this.hasJsx = true;
              }
            }, jsxChecker);
            if (!jsxChecker.hasJsx) {
              return;
            }
            // 在函数体前面添加 const __s = this.$stringify
            path.get('body').unshiftContainer('body', t.variableDeclaration('const', [t.variableDeclarator(t.identifier('__s'), t.memberExpression(t.thisExpression(), t.identifier('$stringify')))]));
            // 在函数体前面添加 const __extend = this.$extend
            path.get('body').unshiftContainer('body', t.variableDeclaration('const', [t.variableDeclarator(t.identifier('__extend'), t.memberExpression(t.thisExpression(), t.identifier('$extend')))]));
            // 在函数体前面添加 const __elem = this.$createElement
            path.get('body').unshiftContainer('body', t.variableDeclaration('const', [t.variableDeclarator(t.identifier('__elem'), t.memberExpression(t.thisExpression(), t.identifier('$createElement')))]));
          }
        });
      }
    }

    /**
     * 生成createElement函数调用
     * @param path
     * @param file
     * @returns {*}
     */
  };function buildElementCall(path, file) {
    path.parent.children = t.react.buildChildren(path.parent);
    var tagExpr = convertJSXIdentifier(path.node.name);
    var args = [];

    // 取出标签名
    var tagName = void 0;
    if (t.isIdentifier(tagExpr)) {
      tagName = tagExpr.name;
      args.push(t.stringLiteral(tagName));
    } else {
      args.push(tagExpr);
    }

    // 生成属性表达式
    var attrs = path.node.attributes;
    if (attrs.length) {
      attrs = buildOpeningElementAttributes(attrs, file);
    } else {
      attrs = t.nullLiteral();
    }
    args.push(attrs);

    return t.callExpression(t.identifier('__elem'), args);
  }

  /**
   *
   * @param type
   * @param value
   * @param file
   */
  function buildTextElementCall(type, value, file) {
    var args = [];
    args.push(t.stringLiteral(type));
    args.push(t.objectExpression([t.objectProperty(t.identifier('value'), t.callExpression(t.identifier('__s'), [t.stringLiteral(value)]))]));
    return t.callExpression(t.identifier('__elem'), args);
  }

  /**
   * 转换JSX符号
   * @param node
   * @param parent
   * @returns {*}
   */
  function convertJSXIdentifier(node) {
    if (t.isJSXIdentifier(node)) {
      node.type = 'Identifier'; // 将type从JSXIdentifier改为Identifier
    }
    return node;
  }

  /**
   * 生成标签的属性表达式
   * @param attribs
   * @param file
   * @returns {*}
   */
  function buildOpeningElementAttributes(attrs, file) {
    var _props = [];
    var objs = [];
    var hasSpread = false;

    function pushProps() {
      if (!_props.length) return;
      objs.push(t.objectExpression(_props));
      _props = [];
    }

    while (attrs.length) {
      var prop = attrs.shift();
      if (t.isJSXSpreadAttribute(prop)) {
        pushProps();
        hasSpread = true;
        objs.push(prop.argument);
      } else {
        _props.push(convertAttribute(prop));
      }
    }

    pushProps();

    if (hasSpread) {
      // $extend表达式
      objs.unshift(t.objectExpression([]));
      attrs = t.callExpression(t.identifier('__extend'), objs);
    } else {
      attrs = objs[0];
    }
    return attrs;
  }

  /**
   *
   * @param node
   */
  function convertAttribute(node) {
    var value = convertAttributeValue(node.value || t.booleanLiteral(true));
    if (t.isStringLiteral(value) && !t.isJSXExpressionContainer(node.value)) {
      value.value = value.value.replace(/\n\s+/g, ' ');
    }
    if (t.isValidIdentifier(node.name.name)) {
      node.name.type = 'Identifier';
    } else {
      node.name = t.stringLiteral(node.name.name);
    }
    return t.inherits(t.objectProperty(node.name, value), node);
  }

  /**
   *
   * @param node
   * @returns {*}
   */
  function convertAttributeValue(node) {
    if (t.isJSXExpressionContainer(node)) {
      return node.expression;
    } else {
      return node;
    }
  }
};