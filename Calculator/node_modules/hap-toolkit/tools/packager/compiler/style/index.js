/*
 * Copyright (C) 2017, hapjs.org. All rights reserved.
 */

'use strict';

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _css = require('css');

var _css2 = _interopRequireDefault(_css);

var _cssWhat = require('css-what');

var _cssWhat2 = _interopRequireDefault(_cssWhat);

var _validator = require('./validator');

var _compress = require('./compress');

var _config = require('../../common/config');

var _utils = require('../../common/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 处理@import
 * @desc 支持 @import '.file.css';或者 @import url(./file.css);
 * @param csscode
 * @param dir
 * @param log
 * @param depList
 * @returns {*}
 */
function processImport(csscode, dir, log, depList) {
  var mergeCode = csscode;
  // 处理@import
  var importList = csscode.match(/@import\s+((?:['"]([^()]+?)['"])|(?:(?:url\(([^()]+?)\))))\s*;/g);
  if (importList && importList.length > 0) {
    if (dir) {
      // 读取css
      importList.forEach(function (res) {
        var inMatch = res.match(/(?:['"]([^()]+?)['"])|(?:(?:url\(([^()]+?)\)))/);
        if (inMatch.length > 1) {
          var importPath = _path2.default.resolve(dir, inMatch[1] || inMatch[2]);
          var importCode = _fs2.default.readFileSync(importPath);
          if (importCode) {
            var importDir = _path2.default.dirname(importPath);
            mergeCode = mergeCode.replace(res, '\n' + processImport(importCode.toString(), importDir, log, depList) + '\n');
            depList.push(importPath);
          } else {
            log.push({
              line: 1,
              column: 1,
              reason: 'ERROR: 找不到文件 `' + res + '` , 导入失败'
            });
          }
        }
      });
    } else {
      log.push({
        line: 1,
        column: 1,
        reason: 'ERROR: 找不到资源路径, 无法处理@import'
      });
    }
  }
  return mergeCode;
}

/**
 * 解析<style>为JSON对象
 * @param code
 * @param done
 */
function parse(source, callback) {
  var err = void 0;
  var jsonStyle = {};
  var log = [];

  var code = source.code || '';
  var filePath = source.filePath;
  var curDir = _path2.default.dirname(filePath);
  // 引入的CSS文件列表
  var depList = [];

  // 合并css
  code = processImport(code, curDir, log, depList);

  // css解析
  var ast = _css2.default.parse(code, { silent: true });

  // 异常处理，打印错误
  if (ast.stylesheet.parsingErrors && ast.stylesheet.parsingErrors.length) {
    err = ast.stylesheet.parsingErrors;
    err.forEach(function (err) {
      log.push({
        line: err.line,
        column: err.column,
        reason: err.toString()
      });
    });
  }

  // 遍历
  if (ast && ast.type === 'stylesheet' && ast.stylesheet && ast.stylesheet.rules && ast.stylesheet.rules.length) {
    // 遍历样式规则
    ast.stylesheet.rules.forEach(function (rule) {
      var type = rule.type;
      var ruleResult = {};

      // 只考虑rule和fontface，其余暂时不支持
      if (type === 'rule') {
        if (rule.declarations && rule.declarations.length) {
          rule.declarations.forEach(function (declaration) {
            var subType = declaration.type;

            // 只考虑声明类型
            if (subType !== 'declaration') {
              return;
            }
            // 样式的属性和值
            var name = declaration.property;
            var value = declaration.value;

            // 校验属性值
            var camelCasedName = (0, _utils.hyphenedToCamelCase)(name);
            var subResult = (0, _validator.validate)(camelCasedName, value, { filePath: filePath });

            subResult.value.forEach(function (item) {
              // 如果校验成功，则保存转换后的属性值
              if ((0, _utils.isValidValue)(item.v)) {
                ruleResult[item.n] = item.v;
              }
            });

            if (subResult.log) {
              log.push({
                line: declaration.position.start.line,
                column: declaration.position.start.column,
                reason: subResult.log.reason
              });
            }
          });

          // 单个选择器：tag, class, id
          var REGEXP_SEL = /^[.#]?[A-Za-z0-9_\-:]+$/;
          // 复合选择器：tag, class, id后代选择
          var REGEXP_SEL_COMPLEX = /^([.#]?[A-Za-z0-9_-]+(\s+|\s*>\s*))+([.#]?[A-Za-z0-9_\-:]+)$/;
          rule.selectors.forEach(function (selector) {
            // 定义
            var hash = {
              key: selector,
              val: ruleResult
            };
            if (selector.match(REGEXP_SEL) || selector.match(REGEXP_SEL_COMPLEX)) {
              // 处理伪类
              var isValid = processPseudoClass(hash, log, rule);
              if (!isValid) {
                return;
              } else if (jsonStyle[hash.key] && selector === hash.key && !(0, _utils.equals)(jsonStyle[hash.key], hash.val, cssCompare)) {
                log.push({
                  line: rule.position.start.line,
                  column: rule.position.start.column,
                  reason: 'WARN: 选择器 `' + hash.key + '` 已经存在，后者合并前者'
                });
              }

              // 是否编译复合选择器,生成_meta信息
              if (!_config.options.optimizeDescMeta && selector.match(REGEXP_SEL_COMPLEX)) {
                try {
                  hash.val = Object.assign({}, hash.val);
                  hash.val._meta = {};
                  hash.val._meta.ruleDef = (0, _compress.compressDescSelector)((0, _cssWhat2.default)(hash.key));
                } catch (err) {
                  log.push({
                    line: rule.position.start.line,
                    column: rule.position.start.column,
                    reason: 'ERROR: 选择器 `' + hash.key + '` 不支持'
                  });
                  return;
                }
              }

              // 如果样式已经存在,则叠加,覆盖同名属性
              jsonStyle[hash.key] = (0, _utils.extend)({}, jsonStyle[hash.key] || {}, hash.val);
            } else {
              log.push({
                line: rule.position.start.line,
                column: rule.position.start.column,
                reason: 'ERROR: 选择器 `' + selector + '` 非法'
              });
            }
          });
        }
      } else if (type === 'font-face') {
        if (rule.declarations && rule.declarations.length) {
          rule.declarations.forEach(function (declaration) {
            /* istanbul ignore if */
            if (declaration.type !== 'declaration') {
              return;
            }

            var name = (0, _utils.hyphenedToCamelCase)(declaration.property);
            var value = declaration.value;
            if (name === 'fontFamily' && '\''.indexOf(value[0]) > -1) {
              // 剔除字体名的外层引号
              value = value.slice(1, value.length - 1);
            }
            ruleResult[name] = value;
          });

          // 所有的fontface放入一个数组中
          if (!jsonStyle['@FONT-FACE']) {
            jsonStyle['@FONT-FACE'] = [];
          }
          jsonStyle['@FONT-FACE'].push(ruleResult);
        }
      } else if (type === 'keyframes') {
        if (rule.keyframes && rule.keyframes.length) {
          var name = rule.name;
          var frameResult = [];

          rule.keyframes.forEach(function (keyframe) {
            var keyResult = void 0;
            /* istanbul ignore if */
            if (keyframe.type !== 'keyframe') {
              return;
            }

            // 处理关键帧内部样式
            if (keyframe.declarations && keyframe.declarations.length) {
              keyResult = {};
              keyframe.declarations.forEach(function (declaration) {
                var subType = declaration.type;

                /* istanbul ignore if */
                if (subType !== 'declaration') {
                  return;
                }

                // 样式的属性和值
                var subname = declaration.property;
                var subvalue = declaration.value;
                // 校验属性值
                var subcamelCasedName = (0, _utils.hyphenedToCamelCase)(subname);
                var subResult = (0, _validator.validate)(subcamelCasedName, subvalue);

                subResult.value.forEach(function (item) {
                  // 如果校验成功，则保存转换后的属性值
                  if ((0, _utils.isValidValue)(item.v)) {
                    keyResult[item.n] = item.v;
                  }
                });

                if (subResult.log) {
                  log.push({
                    line: declaration.position.start.line,
                    column: declaration.position.start.column,
                    reason: subResult.log.reason
                  });
                }
              });

              // 检查对象是否为空
              if ((0, _utils.isEmptyObject)(keyResult)) {
                log.push({
                  line: rule.position.start.line,
                  column: rule.position.start.column,
                  reason: 'ERROR: 动画 `' + name + '` 的关键帧 `' + JSON.stringify(keyframe.values) + '` 没有有效的属性'
                });
              } else {
                // 可能包含多个
                var percentValue = void 0;
                keyframe.values.forEach(function (v) {
                  if (v === 'from') {
                    percentValue = 0;
                  } else if (v === 'to') {
                    percentValue = 100;
                  } else {
                    percentValue = parseFloat(v.replace('%', ''));
                  }
                  keyResult['time'] = percentValue;
                  frameResult.push(keyResult);
                });
              }
            }
          });
          // 排序
          frameResult.sort(function (a, b) {
            return a.time - b.time;
          });

          // 所有的keyframes放入一个数组中
          if (!jsonStyle['@KEYFRAMES']) {
            jsonStyle['@KEYFRAMES'] = {};
          }
          jsonStyle['@KEYFRAMES'][name] = frameResult;
        }
      }
    });
  }
  // 是否压缩CSS属性名
  if (_config.options.optimizeCssAttr) {
    (0, _compress.compressCssAttr)(jsonStyle);
  }
  callback(err, {
    jsonStyle: jsonStyle,
    depList: depList,
    log: log
  });
}

/**
 * 处理伪类，将伪类写到Style的每个值上
 * @param hash
 * @return {boolean}
 */
function processPseudoClass(hash, log, rule) {
  // 处理伪选择器
  var pseudoIndex = hash.key.indexOf(':');
  if (pseudoIndex > -1) {
    var pseudoCls = hash.key.slice(pseudoIndex);
    if (!(0, _validator.validatePseudoClass)(pseudoCls)) {
      log.push({
        line: rule.position.start.line,
        column: rule.position.start.column,
        reason: 'ERROR: 不支持伪类选择器`' + pseudoCls + '`'
      });
      return false;
    }
    hash.key = hash.key.slice(0, pseudoIndex);
    var pseudoRuleResult = {};
    // 将伪选择器text:active中的样式color属性名转换为color:active
    Object.keys(hash.val).forEach(function (prop) {
      pseudoRuleResult[prop + pseudoCls] = hash.val[prop];
    });
    hash.val = pseudoRuleResult;
  }
  return true;
}

/**
 * 复合选择器中的_meta不做比较
 * @param v1
 * @param v2
 * @param keyName
 * @return {boolean}
 */
function cssCompare(v1, v2, keyName) {
  if (keyName === '_meta') {
    return true;
  }
}

module.exports = {
  parse: parse,
  validateDelaration: _validator.validate
};