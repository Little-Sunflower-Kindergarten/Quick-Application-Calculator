/*
 * Copyright (C) 2017, hapjs.org. All rights reserved.
 */

'use strict';

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _jszip = require('jszip');

var _jszip2 = _interopRequireDefault(_jszip);

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _sign = require('../../common/sign');

var _sign2 = _interopRequireDefault(_sign);

var _utils = require('../../common/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ZipPlugin(options) {
  this.options = options;
}

var projDir = process.cwd();

// 签名文件
var SignFileConfig = {
  debug: {
    privatekey: _path2.default.join(projDir, 'sign/debug/private.pem'),
    certificate: _path2.default.join(projDir, 'sign/debug/certificate.pem')
  },
  release: {
    privatekey: _path2.default.join(projDir, 'sign/release/private.pem'),
    certificate: _path2.default.join(projDir, 'sign/release/certificate.pem')
  }
};

function parse(base, dir, cb, thisFS) {
  dir = dir || '.';
  var directory = _path2.default.posix.join(base, dir);
  var name = void 0;
  // 递归遍历目录
  thisFS.readdirSync(directory).forEach(function (file) {
    var fullpath = _path2.default.posix.join(directory, file);
    var stat = thisFS.statSync(fullpath);
    if (stat.isFile()) {
      // 替换
      var posixdir = dir.split(_path2.default.sep).join(_path2.default.posix.sep);
      name = _path2.default.posix.join(posixdir, _path2.default.basename(file));
      cb(name, fullpath);
    } else if (stat.isDirectory()) {
      var subdir = _path2.default.posix.join(dir, file);
      parse(base, subdir, cb, thisFS);
    }
  });
}

/**
 * Watch模式下替换SockJS注入的依赖内容
 * @param filePath
 * @param fileCont
 * @returns {*}
 */
function removeWebpackCode(filePath, fileCont) {
  if (!/\.js$/.test(filePath)) {
    // 非JS原样返回
    return fileCont;
  }

  // 删除第一个webpackRequire类库的引入
  if (/app\.js$/.test(filePath)) {
    fileCont = fileCont.replace(/\n\W__webpack_require__\(\d+\);\n/, '\n');
  }

  return fileCont;
}

ZipPlugin.prototype.apply = function (compiler) {
  var options = this.options;
  var webpackOptions = compiler.options;
  // 是否处于构建模式，不是监听watch
  var isBuildMode = !webpackOptions.watch;
  // 签名：无，debug，release
  var signFile = SignFileConfig[options.sign];

  var pathBuild = options.pathBuild;

  compiler.plugin('after-emit', function (compilation, callback) {
    // Watch模式：JS在内存中
    // const innerInputFS = this.inputFileSystem
    var innerOutputFS = this.outputFileSystem;

    if (!signFile) {
      _utils.colorconsole.log('### App Loader ### 无签名配置项, 放弃打包: ' + options.sign);
      return;
    }
    if (signFile && !_fs2.default.existsSync(signFile.privatekey)) {
      _utils.colorconsole.log('### App Loader ### 缺少私钥文件, 打包失败: ' + signFile.privatekey);
      return;
    }
    if (signFile && !_fs2.default.existsSync(signFile.certificate)) {
      _utils.colorconsole.log('### App Loader ### 缺少证书文件, 打包失败: ' + signFile.certificate);
      return;
    }

    // 生成压缩包
    innerOutputFS.mkdirp(options.output);
    // 文件hash列表
    var filehashs = [];
    var zipper = new _jszip2.default();

    var outputFS = _fs2.default;
    // 读取build目录
    if (!webpackOptions.devServer) {
      // 正常构建时build目录复制
      parse(pathBuild, '.', function (name, file) {
        var fileCont = outputFS.readFileSync(file);
        filehashs.push({
          name: Buffer.from(name),
          hash: _sign2.default.hashFile(fileCont)
        });
        zipper.file(name, fileCont);
      }, outputFS);
    } else {
      // dev-server时内存复制
      parse(pathBuild, '.', function (name, file) {
        var fileCont = removeWebpackCode(file, innerOutputFS.readFileSync(file).toString());
        if (fileCont !== undefined) {
          filehashs.push({
            name: Buffer.from(name),
            hash: _sign2.default.hashFile(fileCont)
          });
          zipper.file(name, fileCont);
        }
      }, innerOutputFS);
      // dev-server时build目录复制
      parse(pathBuild, '.', function (name, file) {
        var fileCont = outputFS.readFileSync(file);
        filehashs.push({
          name: Buffer.from(name),
          hash: _sign2.default.hashFile(fileCont)
        });
        zipper.file(name, fileCont);
      }, outputFS);
    }

    // 写入文件
    zipper.generateAsync({
      type: 'nodebuffer',
      compression: 'DEFLATE',
      compressionOptions: {
        level: 9
      }
    }).then(function (content) {
      // 确定产出文件
      var rpkBuildFileName = options.name + '.' + options.sign + '.rpk';
      var rpkBuildFilePath = _path2.default.join(options.output, rpkBuildFileName);
      _utils.colorconsole.log('### App Loader ### dist\u76EE\u5F55\u7B7E\u540D\u5E76\u751F\u6210rpk\u6587\u4EF6\uFF1A' + rpkBuildFileName);

      // 生成签名文件
      var privatekey = _fs2.default.readFileSync(signFile.privatekey);
      var certpem = _fs2.default.readFileSync(signFile.certificate);
      var signContent = _sign2.default.signZip({
        content: content,
        files: filehashs
      }, privatekey, certpem);
      outputFS.writeFileSync(rpkBuildFilePath, signContent);

      // 复制一份：包名，版本，时间戳
      if (isBuildMode) {
        var dupBuildFileTime = (0, _moment2.default)().format('YYYYMMDDhhmmss');
        var dupBuildFileName = options.name + '_' + options.sign + '_' + options.versionCode + '_' + dupBuildFileTime + '.rpk';
        var dupBuildFilePath = _path2.default.join(options.output, dupBuildFileName);
        outputFS.writeFileSync(dupBuildFilePath, outputFS.readFileSync(rpkBuildFilePath));
        _utils.colorconsole.log('### App Loader ### \u590D\u5236rpk\u6587\u4EF6(' + rpkBuildFileName + ')\u4E3A\u6587\u4EF6(' + dupBuildFileName + ')');
      }

      callback();
    });
  });
};

module.exports = ZipPlugin;