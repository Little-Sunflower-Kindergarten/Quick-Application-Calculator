/*
 * Copyright (C) 2017, hapjs.org. All rights reserved.
 */

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parse = require('parse5');

var _parse2 = _interopRequireDefault(_parse);

var _parser = require('parse5/lib/parser');

var _parser2 = _interopRequireDefault(_parser);

var _tokenizer = require('parse5/lib/tokenizer');

var _tokenizer2 = _interopRequireDefault(_tokenizer);

var _validator = require('./validator');

var _validator2 = _interopRequireDefault(_validator);

var _compress = require('./compress');

var _config = require('../../common/config');

var _utils = require('../../common/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 计算支持span的节点的有效子节点数
 * @param tagName - 标签名
 * @param childNodes - 标签的子节点
 * @returns {number}
 */
function calcSubTextNodesNum(tagName, childNodes) {
  var subTextNodesNum = 0;
  if (_validator2.default.isSupportSpan(tagName)) {
    var tagChildren = _validator2.default.getTagChildren(tagName);
    childNodes.forEach(function (child) {
      if (child.nodeName === '#text' && child.value.trim() || tagChildren.indexOf(child.nodeName) > -1) {
        ++subTextNodesNum;
      }
    });
  }
  return subTextNodesNum;
}

/**
 * 遍历模板,检查标签、属性和子节点是否合法
 * @param node
 * @param output
 * @param previousNode
 * @param conditionList
 * @param options
 */
function traverse(node, output, previousNode, conditionList, options) {
  // 检查标签名
  _validator2.default.checkTagName(node, output);

  // 处理标签属性
  // attrs: id/class/style/if/for/event/attr/show
  var attrs = node.attrs || [];
  attrs.forEach(function switchAttr(attr) {
    var name = attr.name;
    var inMatch = name.match(/^:+/);
    if (inMatch) {
      name = name.slice(inMatch.length);
    }
    var value = attr.value;

    // 获取位置信息
    var locationInfo = { line: 1, column: 1 };
    if (node.__location) {
      locationInfo = {
        line: node.__location.line,
        column: node.__location.col
      };
    }

    switch (name) {
      case 'id':
        // 保留checkId为兼容原有：新打的RPK包兼容原来的APK平台
        _validator2.default.checkId(value, output);
        _validator2.default.checkAttr(name, value, output, node.tagName, locationInfo);
        break;
      case 'class':
        _validator2.default.checkClass(value, output);
        break;
      case 'style':
        _validator2.default.checkStyle(value, output, locationInfo, options);
        break;
      case 'if':
        if (!node._isroot) {
          _validator2.default.checkIf(value, output, false, locationInfo, conditionList);
        }
        break;
      case 'else':
        if (!node._isroot) {
          if (previousNode && previousNode.__cond__) {
            _validator2.default.checkElse(previousNode.__cond__, output, locationInfo, conditionList);
          }
        }
        break;
      case 'elif':
        if (!node._isroot) {
          if (previousNode && previousNode.__cond__) {
            node.__cond__ = _validator2.default.checkElif(value, previousNode.__cond__, output, locationInfo, conditionList);
          }
        }
        break;
      case 'for':
        if (!node._isroot) {
          _validator2.default.checkFor(value, output, locationInfo);
        }
        break;
      case 'tree':
        _validator2.default.checkBuild('tree', output);
        break;
      default:
        if (name.match(/^(on|@)/)) {
          // 事件以on或@开头
          _validator2.default.checkEvent(name, value, output);
        } else {
          // 其余为普通属性
          _validator2.default.checkAttr(name, value, output, node.tagName, locationInfo);
        }
    }
  });

  // 处理子节点
  var originResult = output.result;
  var childNodes = node.childNodes;
  if (childNodes && childNodes.length) {
    var previous = void 0;
    var curNodeCondList = [];
    // 支持span的节点的有效子节点数
    var subTextNodesNum = calcSubTextNodesNum(originResult.type, childNodes);

    childNodes.forEach(function (child, i) {
      if (i > 0) {
        var prenode = childNodes[i - 1];
        if (!prenode.nodeName.match(/^#/)) {
          previous = prenode;
          if (!previous.__cond__) {
            previous.attrs && previous.attrs.forEach(function (attr) {
              if (attr.name === 'if' || attr.name === 'elif') {
                previous.__cond__ = attr.value;
              }
            });
          }
        }
      }
      var childResult = {};
      if (child.nodeName.match(/^#/)) {
        // 处理#text节点内容
        if (child.nodeName === '#text' && child.value.trim()) {
          // 父节点支持span, 且有效子节点数不少于2，自动添加为span节点
          if (_validator2.default.isSupportSpan(node.tagName) && subTextNodesNum >= 2) {
            childResult.type = 'span';
            output.result = childResult;
            originResult.children = originResult.children || [];
            originResult.children.push(childResult);
            _validator2.default.checkAttr('value', child.value, output);
          }

          // 如果父节点是option, 处理value和content属性
          if (node.tagName === 'option') {
            var tempResult = output.result;
            output.result = originResult;
            if (!originResult.attr.hasOwnProperty('value')) {
              _validator2.default.checkAttr('value', child.value, output);
            }
            _validator2.default.checkAttr('content', child.value, output);
            output.result = tempResult;
            return;
          }

          // 父节点支持span，且有且仅有一个有效子节点，或父节点为允许文本内容的原子节点，直接设置value值
          if (_validator2.default.isSupportSpan(node.tagName) && subTextNodesNum === 1 || _validator2.default.isTextContentAomtic(node.tagName)) {
            var _tempResult = output.result; // 备份当前result
            output.result = originResult;
            _validator2.default.checkAttr('value', child.value, output);
            output.result = _tempResult;
          }
        }
        return;
      }
      output.result = childResult;
      originResult.children = originResult.children || [];
      originResult.children.push(childResult);
      traverse(child, output, previous, curNodeCondList, options);
    });

    // 无孩子
    if (originResult.children && originResult.children.length === 0) {
      originResult.children = undefined;
    }
  }
  output.result = originResult;
}

/**
 * 对模板解析器的配置初始化
 * @param code
 * @param options
 */
function initParser(code, options) {
  var parser = new _parser2.default(options);
  var oldAppendElement = parser._appendElement;
  var oldInsertElement = parser._insertElement;
  // 支持自闭合标签
  parser._insertElement = function (token, namespaceURI) {
    var tn = (token.tagName || '').toLowerCase();
    var sc = token.selfClosing;
    // Fixed 对不允许自闭合的标签进行提示
    var isSupSc = _validator2.default.isSupportedSelfClosing(tn);
    if (sc && !isSupSc) {
      _utils.colorconsole.error(tn + '标签，禁止使用自闭合');
    }

    if (isSupSc || sc && tn) {
      oldAppendElement.apply(this, arguments);
    } else {
      oldInsertElement.apply(this, arguments);
    }
  };

  parser.__m = {};
  // 对标签进行xml规范检查
  function checkToken(token) {
    var tn = (token.tagName || '').toLowerCase();
    var sc = token.selfClosing;
    var isSupSc = _validator2.default.isSupportedSelfClosing(tn);

    if (parser.__m['tn'] && tn && !parser.__m['sc']) {
      var pos = String(token.location.line) + String(token.location.col);
      if (!isSupSc || pos !== parser.__m['pos'] && token.type === _tokenizer2.default.START_TAG_TOKEN) {
        _utils.colorconsole.warn(parser.__m['tn'] + '标签要闭合，请遵循XML规范');
        parser.__m = {};
      }
    }

    if (tn && isSupSc) {
      if (token.type === _tokenizer2.default.START_TAG_TOKEN && !sc) {
        parser.__m['tn'] = tn;
        parser.__m['sc'] = false;
        parser.__m['pos'] = String(token.location.line) + String(token.location.col);
      }

      if (token.type === _tokenizer2.default.END_TAG_TOKEN && tn === parser.__m['tn']) {
        parser.__m['sc'] = true;
      }
    }
  }

  parser._runParsingLoop = function (scriptHandler) {
    while (!this.stopped) {
      this._setupTokenizerCDATAMode();

      var token = this.tokenizer.getNextToken();

      checkToken(token);

      if (token.type === _tokenizer2.default.HIBERNATION_TOKEN) {
        break;
      }

      if (this.skipNextNewLine) {
        this.skipNextNewLine = false;

        if (token.type === _tokenizer2.default.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === '\n') {
          if (token.chars.length === 1) {
            continue;
          }

          token.chars = token.chars.substr(1);
        }
      }

      this._processInputToken(token);

      if (scriptHandler && this.pendingScript) {
        break;
      }
    }
  };

  return parser.parseFragment(code);
}

function parse(source, callback) {
  // 解析模板代码
  var doc = initParser(source.code, { treeAdapter: _parse2.default.treeAdapters.default, locationInfo: true });
  var filePath = source.filePath;
  var output = { result: {}, log: []

    // 模板为空或解析失败
    /* istanbul ignore if */
  };if (!doc || !doc.childNodes) {
    output.log.push({ reason: 'ERROR: <template>解析失败', line: 1, column: 1 });
    callback(null, {
      jsonTemplate: output.result,
      log: output.log
    });
    return;
  }

  // 过滤合法标签名，如果标签名以#开头，则代表节点被注释或者#text, #comment
  var rootElements = doc.childNodes.filter(function (child) {
    return child.nodeName.charAt(0) !== '#';
  });

  // 合法节点数目只能等于1,0表示没有根容器
  /* istanbul ignore if */
  if (rootElements.length === 0) {
    output.log.push({ reason: 'ERROR: 没有合法的根节点', line: 1, column: 1 });
    callback(null, {
      jsonTemplate: output.result,
      log: output.log
    });
    return;
  }

  // 合法节点数目只能等于1,否则模板存在多个根容器
  if (rootElements.length > 1) {
    output.log.push({ reason: 'ERROR: <template>节点里只能有一个根节点', line: 1, column: 1 });
    callback(null, {
      jsonTemplate: output.result,
      log: output.log
    });
    return;
  }

  // 从根目录开始, 遍历树
  var current = rootElements[0];
  current._isroot = true;
  traverse(current, output, null, null, { filePath: filePath });

  // 检查是否包含ERROR记录
  // if (output.log.length > 0) {
  // }

  // 是否压缩模板属性名
  if (_config.options.optimizeTemplateAttr) {
    (0, _compress.compressTemplateAttr)(output.result);
  }

  // 执行回调
  callback(null, {
    jsonTemplate: output.result,
    log: output.log
  });
}

exports.default = {
  parse: parse
};